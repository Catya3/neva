// Package parser implements source code parsing.
// It uses parser (and lexer) generated by ANTLR4 from neva.g4 grammar file.
package parser

import (
	"fmt"

	"github.com/antlr4-go/antlr/v4"
	yaml "gopkg.in/yaml.v3"

	"github.com/nevalang/neva/internal/compiler"
	generated "github.com/nevalang/neva/internal/compiler/parser/generated"
	src "github.com/nevalang/neva/pkg/sourcecode"
)

type treeShapeListener struct {
	*generated.BasenevaListener
	file src.File
}

type Parser struct {
	isDebug bool
}

func (p Parser) ParseManifest(raw []byte) (src.ModuleManifest, error) {
	var result src.ModuleManifest
	if err := yaml.Unmarshal(raw, &result); err != nil {
		return src.ModuleManifest{}, fmt.Errorf("yaml unmarshal: %w", err)
	}
	return result, nil
}

func (p Parser) ParseModules(rawMods map[src.ModuleRef]compiler.RawModule) (map[src.ModuleRef]src.Module, error) {
	parsedMods := make(map[src.ModuleRef]src.Module, len(rawMods))
	for modRef, rawMod := range rawMods {
		parsedPkgs, err := p.ParsePackages(rawMod.Packages)
		if err != nil {
			return nil, err
		}
		parsedMods[modRef] = src.Module{
			Manifest: rawMod.Manifest,
			Packages: parsedPkgs,
		}
	}
	return parsedMods, nil
}

func (p Parser) ParsePackages(rawPkgs map[string]compiler.RawPackage) (map[string]src.Package, error) {
	packages := make(map[string]src.Package, len(rawPkgs))

	for pkgName, pkgFiles := range rawPkgs {
		parsedFiles, err := p.ParseFiles(pkgFiles)
		if err != nil {
			return nil, fmt.Errorf("parse files: %w", err)
		}

		packages[pkgName] = parsedFiles
	}

	return packages, nil
}

func (p Parser) ParseFiles(files map[string][]byte) (map[string]src.File, error) {
	result := make(map[string]src.File, len(files))

	for name, bb := range files { // TODO parse in parallel
		name := name
		bb := bb
		v, err := p.ParseFile(bb)
		if err != nil {
			return nil, err
		}
		result[name] = v
	}

	return result, nil
}

func (p Parser) ParseFile(bb []byte) (src.File, error) {
	input := antlr.NewInputStream(string(bb))
	lexer := generated.NewnevaLexer(input)
	tokenStream := antlr.NewCommonTokenStream(lexer, 0)

	parse := generated.NewnevaParser(tokenStream)
	if p.isDebug {
		parse.AddErrorListener(antlr.NewDiagnosticErrorListener(true))
	}
	parse.BuildParseTrees = true

	tree := parse.Prog()
	listener := &treeShapeListener{}

	antlr.ParseTreeWalkerDefault.Walk(listener, tree)

	return listener.file, nil
}

func MustNew(debug bool) Parser {
	return Parser{
		isDebug: debug,
	}
}
