// Code generated by Neva. DO NOT EDIT.
package main

import (
    "context"
    "os"

    "github.com/emil14/neva/internal/runtime"
    {{- range .Routines.Component}}
    "github.com/emil14/neva/internal/runtime/std/{{.Pkg}}"
    {{- end}}
)

func main() {
    // component refs
    {{- range .Routines.Component}}
    {{.Pkg}}{{.Name}}Ref := runtime.ComponentRef{
        Pkg:  "{{.Pkg}}",
        Name: "{{.Name}}",
    }
    {{- end}}

    // routine runner
    repo := map[runtime.ComponentRef]runtime.ComponentFunc{
        {{- range .Routines.Component}}
        {{.Pkg}}{{.Name}}Ref: {{.Pkg}}.{{.Name}},
        {{- end}}
    }
    componentRunner := runtime.NewComponentRunner(repo)
    giverRunner := runtime.GiverRunnerImlp{}
    routineRunner := runtime.NewRoutineRunner(giverRunner, componentRunner)

    // connector
    interceptor := runtime.InterceptorImlp{}
    connector := runtime.NewConnector(interceptor)

    // runtime
    r := runtime.NewRuntime(connector, routineRunner)

    // ports
    {{- range $addr, $buf := .Ports}}
    {{getPortName $addr}} := make(chan runtime.Msg, {{$buf}})
    {{- end}}

	// program
    prog := runtime.Program{
        Ports: map[runtime.PortAddr]chan runtime.Msg{
            {{- range $addr, $buf := .Ports}}
            {
                Path: "{{$addr.Path}}",
                Name: "{{$addr.Port}}",
                Idx: {{$addr.Idx}},
            }: {{$addr.Path}}{{$addr.Port}}{{$addr.Idx}}Port,
            {{- end}}
        },
        Connections: []runtime.Connection{
            {{- range .Connections}}
            {
                Sender: runtime.ConnectionSide{
                    Port: {{.SenderSide.PortAddr.Path}}{{.SenderSide.PortAddr.Port}}{{.SenderSide.PortAddr.Idx}}Port,
                    Meta: runtime.ConnectionSideMeta{
                        PortAddr:  runtime.PortAddr{
                            Path: "{{.SenderSide.PortAddr.Path}}",
                            Name: "{{.SenderSide.PortAddr.Port}}",
                            Idx: {{.SenderSide.PortAddr.Idx}},
                        },
                    },
                },
                Receivers: []runtime.ConnectionSide{
                    {{- range .ReceiverSides }}
                    {
                        Port: {{.PortAddr.Path}}{{.PortAddr.Port}}{{.PortAddr.Idx}}Port,
                        Meta: runtime.ConnectionSideMeta{
                            PortAddr:  runtime.PortAddr{
                                Path: "{{.PortAddr.Path}}",
                                Name: "{{.PortAddr.Port}}",
                                Idx: {{.PortAddr.Idx}},
                            },
                        },
                    },
                    {{- end}}
                },
            },
            {{- end}}
        },
        Routines: runtime.Routines{
            Giver: []runtime.GiverRoutine{
                {{- range $portAddr, $msg := .Routines.Giver}}
                {
                    OutPort: {{$portAddr.Path}}{{$portAddr.Port}}{{$portAddr.Idx}}Port,
                    Msg:     {{getMsg $msg}},
                },
                {{- end}}
            },
            Component: []runtime.ComponentRoutine{
                {{- range .Routines.Component}}
                {
                    Ref: runtime.ComponentRef{
                        Pkg:  "{{.Pkg}}",
                        Name: "{{.Name}}",
                    },
                    IO: runtime.ComponentIO{
                        In: map[string][]chan runtime.Msg{
                            {{- range .PortAddrs.In}}
                            "{{.Port}}": {
                                {{getPorts .Path .Port}}
                            },
                            {{- end}}
                        },
                        Out: map[string][]chan runtime.Msg{
                            {{- range .PortAddrs.Out}}
                            "{{.Port}}": {
                                {{getPorts .Path .Port}}
                            },
                            {{- end}}
                        },
                    },
                },
                {{- end}}
            },
        },
    }

    exitCode, err := r.Run(context.Background(), prog)
    if err != nil {
        panic(err)
    }

    os.Exit(exitCode)
}
