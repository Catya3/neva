package golang

var tmpl = `
// Code generated by Neva. DO NOT EDIT.
package main

import (
    "context"
    "os"

    "github.com/nevalang/neva/internal/compiler/backend/golang/runtime"
    {{- range .Routines.Func}}
    "github.com/nevalang/neva/internal/compiler/backend/golang/runtime/std/{{.Ref.Pkg}}"
    {{- end}}
)

func main() {
    // func refs
    {{- range .Routines.Func}}
    {{.Ref.Pkg}}{{.Ref.Name}}Ref := runtime.FuncRef{
        Pkg:  "{{.Ref.Pkg}}",
        Name: "{{.Ref.Name}}",
    }
    {{- end}}

    // routine runner
    repo := map[runtime.FuncRef]runtime.Func{
        {{- range .Routines.Func}}
        {{.Ref.Pkg}}{{.Ref.Name}}Ref: {{.Ref.Pkg}}.{{.Ref.Name}},
        {{- end}}
    }
    funcRunner := runtime.NewFuncRunner(repo)
    giverRunner := runtime.DefaultGiverRunner{}
    routineRunner := runtime.NewRoutineRunner(giverRunner, funcRunner)

    // connector
    interceptor := runtime.InterceptorImlp{}
    connector := runtime.NewConnector(interceptor)

    // runtime
    r := runtime.NewRuntime(connector, routineRunner)

    // ports
    {{- range $addr, $buf := .Ports}}
    {{getPortChVarName $addr}} := make(chan runtime.Msg, {{$buf}})
    {{- end}}

	// program
    prog := runtime.Program{
        Ports: map[runtime.PortAddr]chan runtime.Msg{
            {{- range $addr, $buf := .Ports}}
            {
                Path: "{{$addr.Path}}",
                Name: "{{$addr.Name}}",
                Idx: {{$addr.Idx}},
            }: {{getPortChVarName $addr}},
            {{- end}}
        },
        Connections: []runtime.Connection{
            {{- range .Connections}}
            {{ getConnComment . }}
            {
                Sender: runtime.ConnectionSide{
                    Port: {{getPortChVarName .SenderSide.PortAddr}},
                    Meta: runtime.ConnectionSideMeta{
                        PortAddr:  runtime.PortAddr{
                            Path: "{{.SenderSide.PortAddr.Path}}",
                            Name: "{{.SenderSide.PortAddr.Name}}",
                            Idx: {{.SenderSide.PortAddr.Idx}},
                        },
                    },
                },
                Receivers: []runtime.ConnectionSide{
                    {{- range .ReceiverSides }}
                    {
                        Port: {{getPortChVarName .PortAddr}},
                        Meta: runtime.ConnectionSideMeta{
                            PortAddr:  runtime.PortAddr{
                                Path: "{{.PortAddr.Path}}",
                                Name: "{{.PortAddr.Name}}",
                                Idx: {{.PortAddr.Idx}},
                            },
                        },
                    },
                    {{- end}}
                },
            },
            {{- end}}
        },
        Routines: runtime.Routines{
            Giver: []runtime.GiverRoutine{
                {{- range $portAddr, $msg := .Routines.Giver}}
                {
                    OutPort: {{getPortChVarName $portAddr}},
                    Msg:     {{getMsg $msg}},
                },
                {{- end}}
            },
            Func: []runtime.FuncRoutine{
                {{- range .Routines.Func}}
                {
                    Ref: runtime.FuncRef{
                        Pkg:  "{{.Ref.Pkg}}",
                        Name: "{{.Ref.Name}}",
                    },
                    IO: runtime.FuncIO{
                        In: map[string][]chan runtime.Msg{
                            {{- range .IO.In}}
                            "{{.Name}}": {
                                {{getPorts .Path .Name}}
                            },
                            {{- end}}
                        },
                        Out: map[string][]chan runtime.Msg{
                            {{- range .IO.Out}}
                            "{{.Name}}": {
                                {{getPorts .Path .Name}}
                            },
                            {{- end}}
                        },
                    },
                },
                {{- end}}
            },
        },
    }

    exitCode, err := r.Run(context.Background(), prog)
    if err != nil {
        panic(err)
    }

    os.Exit(exitCode)
}`
