/*comments*/
// comments

// this text uses comments to describe syntax

use { // list of imports
	std_pkg // could be one word
	imported/from/elsewhere // or separated with slash
	with_alias another/imported/from/elsewhere // or could have alias
}

type { // list of files
    MyErr error // could be aliases to other types
    MyCmplx c128 | c64 // this is type name and type literal expression (union type in this case)
    MyFloat f32
    MyBool bool
    MyStr str
    MyVec<T> []T // type def could contain generic parameter, also []T is a syntax for lists (vectors)
    MyArr<T> [512]T // same as prev but with fixed size (this is array type)
    MyRec<T> { // this is record (structure) type expression, it contains list of field definitions separated by new line
        foo i32 // this is field and its type after whitespace
        bar str // type of the field is also a type expression
        baz MyArr<T>
    }
    MyEnum { // this is enum syntax
        First // simply words separated by newline
        Second
    }
    MyUnion MyFloat | MyVec | MyArr | MyRec | MyEnum // union is a list of any type expressions, simply type reference is a valid type expression too 
}

io { // this is interfaces definition
    // interface name, optionally with generic parameters, btw generic parameters could optionally have constraints like here,
    // interface name is followed by pair of parentheses, first input parameters (input ports - inports), then output parameters (output ports, outports)
    // syntax for ports type is port name (id) followed by type, port and their types separated with comma, like function parameters
    // several ports of the same type could follow each other with only one type definition like in Go
    IMyInterface<T MyUnion>(
        x int,
        y int,
        z str
    ) (z T)
    pub IMyInterface2<T MyUnion>(a bool, b [][]T) (z T) // optional pub keyword means exported entity, any entity, not only interface (io) could be exported
}

const { // list of constants
    MY_STR MyStr = "asd" // constant name (not necessary upper case) followed by "=" and value
    TRUE = true // possible values are true, false, string literals in single or double quote, integer or float number
    PI MyFloat = 3.14
    MY_VEC MyVec<MyFloat> = [PI, PI] // or list of values followed by comma inside square brackets, like JS array
    pub MY_FRIEND MyRec<f32> = { // or record value, looks like JS object but with whitespaces instead of commas for fields separation
        foo: 27, bar: "john", baz: 42.0
    }
}

comp { // this is components list
    // optional pub keyword followed by component name with optional type parameters with optional constraints
    // what comes after optional pub keyword has the same syntax as interface except outports followed by curly braces pair
    // inside curly braces body of the component, it consist of node section and net section
    pub Doer<T f64>(x u32) (z T) {
        node { // node section is optional and could be empty
            abstractNode IMyInterface // this is abstract node. syntax is node name followed by interface name
            printer = std_pkg.Printer() // this is concrete node. syntax is node name followed by concrete node expression
            // concrete node expression is optional prefix with imported package name (this is what comes before dot)
            // then entity name with optional generic argument passing expression (like in case of type expression)
            // then required brackets () with optional list of other concrete node expressions
            reader = elsewhere.Reader<str>() 
            // this is example where we pass one concrete node expression into another
            reader2 = elsewhere.Reader<str>(
                elsewhere.Reader<str>() // they are separated by newline
                elsewhere.Reader<str>() // could be 0 or more, any number
            ) 
        }
        net { // this is list of connections. connection always has one sender (outport) and one or more receivers (inports)
            // sender and receiver are referenced with string that can contain from 2 to 3 elements separated by dot
            // this is simple 1-1 connection for one inport to another outport
            // first part is either "in" or "out" or there's 3 parts: node name, direction "in" or "out" and then port name 
            in.x -> printer.in.v // this is simple 1-1 connection that connects x inport to v inport of the printer node
            printer.out.v -> { // this is 1-2 connection that connects printer's "v" outport to 2 inports: v inport of the reader node and z outport of this Doer component
                reader.in.v // inports separated by newline
                out.z
            }
        }
    }

    Doer2<T f64>(x u32) (z T) { // could be more than one component
        node {
            abstractNode IMyInterface
            printer = std_pkg.Printer()
            reader = elsewhere.Reader<str>()
        }
        net {
            in.x -> printer.in.v
            printer.out.v -> {
                reader.in.v
                out.z
            }
        }
    }
}

