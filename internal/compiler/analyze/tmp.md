> **Проблема**: рекурсивный обход на уровне семантического анализатора на самом деле не работает, потому что объект Scope, который мы туда передаём, единожды сформирован под первоначальный вызов, с его контекстом (импортами данного пакета), что позволяет сделать рекурсивные вызовы на глубину одного уровня, но не более. т.е если у импорта есть свои импорты, то их видно уже не будет. для этого, нужен в том или ином виде доступ к pkgs - списку всех пакетов. тогда можно будет формировать импорты других пакетов и рекурсивно обходить любые глубины.

# Возможное решение №1:

Формировать scope один раз сразу из всех пакетов.

## Проблема №1 

Импорты выпадают из механизма (держать их только для первого уровня звучит так себе - всё усложнит, мало что даст). Ссылаться на пакеты можно только по "настоящей" ссылке, со всеми вытекающими.

## Проблема №2

Ошибка "ссылаешься на не импортнутое" будет выявлена позднее. Плохо если пакет большой/глубокий - обошли всю глубину/ширину и только в конце поняли, что всё зря.

# Возможное решение #2:

Вытащить ресолвер на уровень анализатора. TODO

## Проблема №1 

Терминатор тоже оперирует со скоупом. TODO точно проблема?

# Возможное решение #3

Комбинация 1 и 2
Scope формируется сразу из всех пакетов,
но импорты в нём присутствуют
а все пакеты нужны чтоб перестраиваться при необходимости
на выходе есть visited который можно сравнить со списком

добавляется метод Update
туда передается реф из которого мы делаем вывод, в какой пакет мы сейчас пойдем
scope перестраивает карту импортов и возвращает новый инстанс
такая апиха дает юзеру согласованно сообщать в какой именно момент он хочет сменить контекст

альтернатива в виде вшивания этой логики прямо в get плоха т.к. не даст ответа на вопрос - ссылался ли пакет на не импортированную сущность или мы легально сменили контекст

проблема

неприятное дублирование кода c analyzeMsg - там мы руками формируем новый скоуп. можно как-то реюзнуть update там?