// Code generated by Neva. DO NOT EDIT.
package main

import (
    "context"

    "github.com/nevalang/neva/internal/runtime"
    "github.com/nevalang/neva/internal/runtime/funcs"
)

func main() {
    // runtime
    connector := runtime.NewDefaultConnector()
	funcRunner := runtime.MustNewFuncRunner(funcs.CreatorRegistry())
	runTime := runtime.New(connector, funcRunner)

    // ports
    inStart0Port := make(chan runtime.Msg, 0)
    outStop0Port := make(chan runtime.Msg, 0)
    inSig0Port := make(chan runtime.Msg, 0)
    inV0Port := make(chan runtime.Msg, 0)
    outV0Port := make(chan runtime.Msg, 0)
    inData0Port := make(chan runtime.Msg, 0)
    outSig0Port := make(chan runtime.Msg, 0)
    inMsg0Port := make(chan runtime.Msg, 0)
    outMsg0Port := make(chan runtime.Msg, 0)
    outMsg0Port := make(chan runtime.Msg, 0)

	// program
    prog := runtime.Program{
        Ports: map[runtime.PortAddr]chan runtime.Msg{
            {
                Path: "in",
                Port: "start",
                Idx: 0,
            }: inStart0Port,
            {
                Path: "out",
                Port: "stop",
                Idx: 0,
            }: outStop0Port,
            {
                Path: "in",
                Port: "sig",
                Idx: 0,
            }: inSig0Port,
            {
                Path: "in",
                Port: "v",
                Idx: 0,
            }: inV0Port,
            {
                Path: "out",
                Port: "v",
                Idx: 0,
            }: outV0Port,
            {
                Path: "in",
                Port: "data",
                Idx: 0,
            }: inData0Port,
            {
                Path: "out",
                Port: "sig",
                Idx: 0,
            }: outSig0Port,
            {
                Path: "in",
                Port: "msg",
                Idx: 0,
            }: inMsg0Port,
            {
                Path: "out",
                Port: "msg",
                Idx: 0,
            }: outMsg0Port,
            {
                Path: "out",
                Port: "msg",
                Idx: 0,
            }: outMsg0Port,
        },
        Connections: []runtime.Connection{
            // in:start[0] -> 
            {
                Sender: inStart0Port,
                Receivers: []chan runtime.Msg{
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "in",
                        Port: "start",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                    },
                },
            },
            // $user/out:msg[0] -> selector/in:msg[0]
            {
                Sender: _userOutMsg0Port,
                Receivers: []chan runtime.Msg{
                    selectorInMsg0Port,
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "$user/out",
                        Port: "msg",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                        {
                            Path: "selector/in",
                            Port: "msg",
                            Idx: 0,
                        },
                    },
                },
            },
            // in:start[0] -> __then_lock_from_in:start_to_$user:msg_/in:sig[0]
            {
                Sender: inStart0Port,
                Receivers: []chan runtime.Msg{
                    __then_lock_from_inStart_to__userMsg_InSig0Port,
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "in",
                        Port: "start",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                        {
                            Path: "__then_lock_from_in:start_to_$user:msg_/in",
                            Port: "sig",
                            Idx: 0,
                        },
                    },
                },
            },
            // $user/out:msg[0] -> __then_lock_from_in:start_to_$user:msg_/in:v[0]
            {
                Sender: _userOutMsg0Port,
                Receivers: []chan runtime.Msg{
                    __then_lock_from_inStart_to__userMsg_InV0Port,
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "$user/out",
                        Port: "msg",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                        {
                            Path: "__then_lock_from_in:start_to_$user:msg_/in",
                            Port: "v",
                            Idx: 0,
                        },
                    },
                },
            },
            // __then_lock_from_in:start_to_$user:msg_/out:v[0] -> selector/in:msg[0]
            {
                Sender: __then_lock_from_inStart_to__userMsg_OutV0Port,
                Receivers: []chan runtime.Msg{
                    selectorInMsg0Port,
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "__then_lock_from_in:start_to_$user:msg_/out",
                        Port: "v",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                        {
                            Path: "selector/in",
                            Port: "msg",
                            Idx: 0,
                        },
                    },
                },
            },
            // selector/out:msg[0] -> printer/in:data[0]
            {
                Sender: selectorOutMsg0Port,
                Receivers: []chan runtime.Msg{
                    printerInData0Port,
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "selector/out",
                        Port: "msg",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                        {
                            Path: "printer/in",
                            Port: "data",
                            Idx: 0,
                        },
                    },
                },
            },
            // printer/out:sig[0] -> out:stop[0]
            {
                Sender: printerOutSig0Port,
                Receivers: []chan runtime.Msg{
                    outStop0Port,
                },
                Meta: runtime.ConnectionMeta{
                    SenderPortAddr: runtime.PortAddr{
                        Path: "printer/out",
                        Port: "sig",
                        Idx: 0,
                    },
                    ReceiverPortAddrs: []runtime.PortAddr{
                        {
                            Path: "out",
                            Port: "stop",
                            Idx: 0,
                        },
                    },
                },
            },
        },
        Funcs: []runtime.FuncCall{
            {
                Ref: "blocker",
                IO: runtime.FuncIO{
                    In: map[string][]chan runtime.Msg{
                        "sig": {
                            inSig0Port,
                        },
                        "v": {
                            inV0Port,
                        },
                    },
                    Out: map[string][]chan runtime.Msg{
                        "v": {
                            outV0Port,
                        },
                    },
                },
                ConfigMsg: nil,
            },
            {
                Ref: "line_printer",
                IO: runtime.FuncIO{
                    In: map[string][]chan runtime.Msg{
                        "data": {
                            inData0Port,
                        },
                    },
                    Out: map[string][]chan runtime.Msg{
                        "sig": {
                            outSig0Port,
                        },
                    },
                },
                ConfigMsg: nil,
            },
            {
                Ref: "struct_selector",
                IO: runtime.FuncIO{
                    In: map[string][]chan runtime.Msg{
                        "msg": {
                            inMsg0Port,
                        },
                    },
                    Out: map[string][]chan runtime.Msg{
                        "msg": {
                            outMsg0Port,outMsg0Port,
                        },
                    },
                },
                ConfigMsg: runtime.NewListMsg(
		runtime.NewStrMsg("pet"),
	runtime.NewStrMsg("name"),
),
            },
            {
                Ref: "emitter",
                IO: runtime.FuncIO{
                    In: map[string][]chan runtime.Msg{
                    },
                    Out: map[string][]chan runtime.Msg{
                        "msg": {
                            outMsg0Port,outMsg0Port,
                        },
                    },
                },
                ConfigMsg: runtime.NewMapMsg(map[string]runtime.Msg{
		"name": runtime.NewStrMsg("John"),
	"pet": runtime.NewMapMsg(map[string]runtime.Msg{
		"name": runtime.NewStrMsg("Charley"),
},
),
},
),
            },
        },
    }
    
    if err := runTime.Run(context.Background(), prog); err != nil {
        panic(err)
    }
}