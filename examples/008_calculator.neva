// This time we gonna build simple calculator.
// And we going to use what we build in the last lesson.
// Here's how it works: print instructions for user, read chosen operation,
// in case it's invalid print error and start again. Otherwise read first num.
// Try to parse it, print error and start (everything) again if needed.
// Do the same for second input. Finally apply operation and print result.

use {
	std
}

const {
	instructions str 'Enter operation:\n\t1) +/n/t2) -/n/t3) */n/t4) /'
	availableInstructions map<str> ['*', '/', '+', '-']
	enterNumMsg str 'Enter number'
	unknownOpErr str 'Unknown operation'
}

components {
	Main(enter str instructions) (exit) {
		nodes {
			print std.Print
			readOp ReadOp
			readFirstNum ReadNum
			readSecondNum ReadNum
			calc Calc
		}
		net {
			in.enter -> readOp.sig // read operation
			readOp.err -> print.v // in case of error print
			readOp.v -> readFirstNum.sig // otherwise read first num
			readFirstNum.err -> print.v // in case of error print
			readFirstNum.v -> { // otherwise send op to calc and read second num
				calc.op
				readSecondNum.sig
			}
			readSecondNum.err -> print.v // in case of error print
			readSecondNum.v -> calc.b // otherwise send second num to calc
			calc.v -> print.v // get result and print it
			print.v -> out.exit // any time we print something we exit
		}
	}
	ReadOp(sig) (v str) {
		nodes {
			read std.Read
			has std.Has
			lockErr std.Lock
			lockResult std.Lock
		}
		net {
			in.sig -> read.sig // read operation
			availableInstructions -> has.vv // configure 'has' component
			read.v -> has.v // check if operation is valid
			has.no -> lockErr.sig // if not valid trigger error locker
			unknownOpErr -> lockErr.v // and lock error itself
			lockErr.v -> out.err // if error unlocked then send it to the outport
			has.yes -> lockResult.sig // otherwise trigger result locker
			has.v -> lockResult.v // and lock result in case it's success
		}
	}
	ReadNum(sig) (v int) {
		nodes {
			read std.Read
			parse std.Parse
			lockErr std.Lock
			lockResult std.Lock
		}
		net {
			in.sig -> read.sig // read number
			read.v -> parse.v // parse it
			parse.err -> out.err // if error trigger error locker
			parse.v -> lockResult.sig // otherwise trigger result locker
			parse.v -> out.v // and send result to the outport
			parse.err -> lockErr.v // lock error in case of error
			lockErr.v -> out.err // and send it to the outport
			lockResult.v -> out.v // send result to the outport
		}
	}
}