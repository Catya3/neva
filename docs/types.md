# Система типов

Есть два вида типов:

1. Типы данных (data types)
2. Типы интерфейсов (interface types)

Типы данных описывают формат сообщения, передаваемого от порта к порту, а тип интерфейса описывает сами порты. Их объединяет общая механика разрешения (resolving) и проверки на совместимость (compatibility check), однако, у них разное предназначение - типы данных описывают, собственно, данные, тогда как типы интерфейсов не могут для этого использоваться. И наоборот, тип данных не может описать интерфейс компонента.

> Теоретически, можно создать тип данных и сообщение этого типа, описывающее интерфейс компонента. Более того, сделать это не так сложно. Это звучит любопытным с точки зрения рефлексии и метапрограммирования, однако, сейчас не об этом. С точки зрения же системы типов приходится различать эти два вида.

У всякого типа есть список параметров (type parameters), который может быть пустым.

## Типы данных

Есть несколько базовых типов данных. Какие-то из них имеют параметризацию, какие-то нет. Среди них есть один особенный тип под название `struct`. Он отличается тем, что даёт его пользователю возможность задать типу данных произвольную структуру в виде списка именованных полей, каждое какого угодно типа.

## Типы интерфейсов

Интерфейс, как уже было сказано выше, можно было бы представить через тип данных. Это была бы структура с двумя полями `in` и `out`, описывающими входные (inports) и выходные (outports) порты соответственно. Значением каждого из этих двух полей был бы словарь, где ключ это имя порта, а значение - тип данных. К сожалению, как, опять же, было подмечено, это невозможно, по причинам которые не относятся к сути дела. Так или иначе, об интерфейсных типах можно думать подобным образом, держа в голове, что они не предназначены для описания сообщений, но служат описанию, собственно, интерфейсов компонентов.

## Разрешение типов

- Разрешённый тип это тип, в котором нет ссылок на не базовые типы данных
- Два разрешённых типа можно проверить на совместимость

### Алгоритм разрешения типа

#### Тип данных

- Проверить, не является ли тип структурным
- Если нет, разрешить его как не структурный тип
    - Взять нижележащий тип, либо, если он не найден, вернуть ошибку
    - Сравнить кол-во параметров в описании типа и разрешаемом выражении
    - Если в описании типа больше параметров, чем в выражении, вернуть ошибку
    - Рекурсивно разрешить каждый аргумент в разрешаемом выражении
    - Проверить, не является ли нижележащий тип базовым и, если да, вернуть результат
    - Иначе рекурсивно повторить для нижележащего типа
- Иначе, разрешить как структурный тип
    - Рекурсивно разрешить каждое поле

Операция "взять нижележащий тип" предполагает, что существует ссылка, которая ведёт к какому-то типу данных. Если тип данных не найден (в том числе, если вместо типа данных найдена иная сущность, например, интерфейс), возвращается ошибка - тип данных состоит только из других типов данных.

#### Тип интерфейса

интерфейсный тип всегда несовместим с типом данных и наоборот

типы данных совместимы, когда:

- Оба являются структурированными или не структурированными
-

интерфейсные типы совместимы, когда:

-

# TODO

обдумать необходимость разделения понятия типов на 2
мб об этом можно думать так что просто есть сущности и какие то из них являются разрешаемыми?
