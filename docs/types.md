Стримы Моррисона решают решают проблему динамических списков, которой нет в conventional programming, как он любит выражаться.

В FBP проблема вида "произведи операцию над множеством значений и верни результат" решается относительно легко,
когда заранее известно количество входных элементов - с помощью array-ports (я бы назвал их скорее "порт группы").
По сути это подмножество всех портов (входных или выходных, зачем нужны последние я пока не понял), которое объединяет
общее имя и каждый имеет свой номер. То есть это как бы "слоты массива".

Но когда неясно (на момент компиляции), как много элементов будет (например, они пришли из интернета), этот трюк не спасает!
Список является, если можно так выразиться, "завершённой" структурой (открестимся, наконец, от императивных языков),
где для её синхронизации уже произошло всё, что должно было произойти. В FBP же всё не так - поток не статичен, он _происходит_.

Меня увлекла софистика. Короче, стримы со скобками эту проблему решают - компонент может понять, когда начинается
список и когда кончается. Мне это решение кажется несколько сложным. Есть вероятность, что можно проще. Возможно, моя альтернатива
либо невозможна, либо менее производительна. Возможно, и то и другое. А может мой способ лучше! Узнаем же.

# Solution to arrays/reducers/mergers

```
in:
    stream: T
out:
    acc: []T 
```

```

Списки (Lists)

Компоненты-аккумуляторы имеют порт общего назначения для самих значений
а также порт

---

Let `T` be a type and let there be a `V` for every `T` where `V ∈ TT`.

`∀ V ∈ A`

`T -> V`

`V ∈ TT`

Let `TT = {bool, int, uint, float, str, struct}`

Type always has list of the parameters `P` defined as `P ⊆ TT`

```

{ x | P(x) }

```

```
