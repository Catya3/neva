# Система типов

Система типов - совокупность правил, назначающих свойства, именуемые _типами_, различным _конструкциям_, составляющим _программу_.

Система типов назначает тип каждому вычисленному _значению_ и затем, отслеживая последовательность этих вычислений, предпринимает попытку проверить или доказать отсутствие _ошибок согласования типов_.

Операция назначения типа, называемая _типизацией_, придаёт смысл цепочкам бит, таким как значение в памяти компьютера, или объектам, таким как "переменная".

Назначение цепочкам бит типа предоставляет осмысление, превращая тем самым программируемое аппаратное обеспечение в _символьную систему_.

Символьная система - система, состоящая из множества _знаков_ и _отношений_ между ними. Обеспечивают единообразное представление и интерпретацию _сообщений_, которыми обмениваются в процессе _общения_.

На практике, лишь некоторые языки могут считаться типизированными с точки зрения _теории типов_, большинство современных языков предлагают лишь некую степень типизированности.

## Полиморфизм

_Полиморфизм_ означает способность кода выполняться над значениями множества разных типов, или возможность разных экземпляров одной и той же структуры данных содержать элементы разных типов.

Некоторые учёные в области информатики иногда называют использование определённых форм полиморфизма _обобщённым программированием_. _Параметрически полиморфные_ функции и типы называют обобщёнными.

_Ad-hoc (ситуативный) полиморфизм_ поддерживается посредством _перегрузки_ функций и методов, а в слабо типизированных также посредством _приведения типов_.

Некоторые языки имеют _унифицированную систему типов_. Это означает, что все типы языка вплоть до примитивных наследуются от единого корневого объекта (в C# от класса Object).

## Согласование

Механизм _проверки согласования типов_ проверяет, что всякое выражение соответствует типу, ожидаемому тем _контекстом_, в котором оно присутствует. Нотация соответствия, называемая _совместимостью_, специфична для каждого языка.

В простейших системах типов вопрос совместимости двух типов упрощается до вопроса их равенства (_эквивалентности_). Разные языки имеют разные критерии для определения совместимости типов двух выражений.

Теории эквивалентности варьируются между двумя крайними случаями: _структурными системами типов_, где два типа эквивалентны, если описывают одинаковую внутреннюю структуру значения; и _номинативными системами типов_, где два типа равны, если равны их идентификаторы.

## Подтипы

В языках с _подтипами_ правила совместимости более сложные. Например, если A является подтипом B, то значение типа A, может быть использовано в контексте, ожидающем значение типа B, даже если обратное неверно. Как и в случае эквивалентности, отношения подтипов различаются в разных языках. Наличие в языке _параметрического_ или _ситуативного полиморфизма_ может также влиять на совместимость типов.

_Ковариантностью_ (_ограничением надтипа_) называется сохранение иерархии наследования исходных типов в производных типах в том же порядке. Так, если класс `Cat` наследуется от класса `Animal`, то естественно полагать, что перечисление `IEnumerable<Cat>` будет потомком перечисления `IEnumerable<Animal>`. Действительно, «список из пяти кошек»— это частный случай «списка из пяти животных». В таком случае говорят, что тип (в данном случае обобщённый интерфейс) `IEnumerable<T>` ковариантен своему параметру-типу `T`. То есть функция может принимать как сам этот тип, так и любой его подтип, но не может принимать надтипы или иные типы.

_Контравариантностью_ (_ограничением подтипа_) называется обращение иерархии исходных типов на противоположную в производных типах. Так, если класс `String` наследуется от класса `Object`, а делегат `Action<T>` определён как метод, принимающий объект типа `T`, то `Action<Object>` наследуется от делегата `Action<String>`, а не наоборот. Действительно, если «все строки - объекты», то «всякий метод, оперирующий произвольными объектами, может выполнить операцию над строкой», но не наоборот. В таком случае говорят, что тип (в данном случае обобщённый делегат) `Action<T>` контравариантен своему параметру-типу `T`. То есть функция может принимать как сам этот тип, так и любой его надтип, но не может принимать подтипы или иные типы.

Отсутствие наследования между производными типами называется _инвариантностью_.
